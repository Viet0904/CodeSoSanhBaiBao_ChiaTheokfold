import cv2
import numpy as np
import os

image = cv2.imread("Guava Dataset/Red_rust/Red Rust(1).jpg")
path = []
visited = []
b = 0
briter = 0


def get_neighbors(position):
    height, width, _ = image.shape
    row, col = position
    neighbors = []
    neighbors_offsets = [
        (0, 1),
        (0, -1),
        (1, 0),
        (-1, 0),
        (1, 1),
        (1, -1),
        (-1, -1),
        (-1, 1),
    ]
    # neighbors_offsets = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    for offset_row, offset_col in neighbors_offsets:
        new_row, new_col = row + offset_row, col + offset_col
        if 0 <= new_row < image.shape[0] and 0 <= new_col < image.shape[1]:
            neighbors.append((new_row, new_col))
    return neighbors


def max_y(lst):
    # Return the pair with the maximum x and y coordinates
    return max(lst, key=lambda pair: (pair[1]))


def difff(x, y):
    if x < y:
        return y - x
    else:
        return x - y


def segmentation():
    current_position = (0, 0)
    # current_position = (np.random.randint(0, image.shape[0]), np.random.randint(0, image.shape[1]))
    path.append(current_position)
    visited.append(current_position)

    green_found = True

    global briter
    while green_found and briter < 2000:
        briter += 1
        neighbors = get_neighbors(current_position)
        # print(neighbors)

        next = None
        min = float("inf")
        for neighbor in neighbors:
            # print(image[neighbor][1],image[current_position][1])
            if (
                (difff(image[neighbor][1], image[current_position][1]) < min)
                and (neighbor not in visited)
                and (image[neighbor][1] > image[neighbor][2])
            ):
                # if image[neighbor][1] < image[neighbor][2]:
                #     #print('nastavio')
                #     continue
                next = neighbor
                min = difff(image[neighbor][1], image[current_position][1])
                print(next, next in visited)
                # if image[next][1] < image[next][2]:
                # print('jeste')
                # print(next,neighbors)

        if next is None:
            next_position = max_y(visited)
            # print('max y',next_position,next_position in visited)
            # print()
            # for _ in get_neighbors(next_position):
            #     print(_ in visited,end=' ')
            # print()

            # print('max',next_position,image[next_position][1],image[next_position][2])

        else:
            next_position = next
            # print(next_position,image[next_position][1],image[next_position][2])

        # if image[next_position][1] < 2 and image[next_position][0] < 2 and image[next_position][2] < 2:
        global b
        if image[next_position][1] < image[next_position][2]:
            b += 1
        else:
            b = 0

        if b == 20:
            print("")
            green_found = False

        path.append(next_position)
        visited.append(next_position)
        current_position = next_position
    print(briter)
    return path


def are_elements_unique(lst):
    print(len(set(lst)))
    return len(lst) == len(set(lst))


segmentation_result = np.zeros_like(image)
result = segmentation()
print(are_elements_unique(result))
for position in result:
    segmentation_result[position] = image[position]

# Đường dẫn đến thư mục để lưu ảnh đã xử lý
output_folder = "processed_images"
os.makedirs(output_folder, exist_ok=True)
image_path = "Guava Dataset/Red_rust/Red Rust(1).jpg"
# Tạo tên file đầu ra dựa trên tên file gốc
output_filename = os.path.join(output_folder, os.path.basename(image_path))

# Lưu ảnh đã xử lý vào thư mục đầu ra
cv2.imwrite(output_filename, result)

print("Đã lưu ảnh đã xử lý vào:", output_filename)
